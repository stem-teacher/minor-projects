--- src/processor.rs
+++ src/processor.rs
@@ -190,6 +190,94 @@ impl PdfProcessor {
 
         Ok(pages_annotated)
     }
+
+    /// Unified annotation approach for all pages
+    fn unified_page_annotation(
+        &self,
+        annotator: &crate::annotation::Annotator,
+        doc: &mut Document,
+        page_id: (u32, u16),
+        text: &str,
+        x: f32,
+        y: f32,
+    ) -> Result<(), crate::error::AnnotationError> {
+        // Step 1: Analyze the page's content stream structure
+        let page_dict = doc.get_dictionary(page_id).map_err(|e| {
+            crate::error::AnnotationError::ContentStreamError(format!("Failed to get page dictionary: {}", e))
+        })?;
+        
+        // Check if the page has a Contents entry and what type it is
+        let content_type = match page_dict.get(b"Contents") {
+            Ok(Object::Array(_)) => "array",
+            Ok(Object::Reference(ref_id)) => {
+                // Check what the reference points to
+                match doc.get_object(*ref_id) {
+                    Ok(Object::Array(_)) => "array_ref",
+                    Ok(Object::Stream(_)) => "stream_ref",
+                    _ => "unknown_ref"
+                }
+            },
+            Ok(Object::Stream(_)) => "direct_stream",
+            _ => "missing"
+        };
+        
+        debug!("Page has content type: {}", content_type);
+        
+        // Step 2: Apply unified annotation approach with adaptive fallbacks
+        match content_type {
+            "array" | "array_ref" => {
+                // For array content streams: append our annotation to existing content
+                self.handle_array_content_page(doc, page_id, text, x, y)
+            },
+            "stream_ref" | "direct_stream" => {
+                // For referenced or direct streams: try standard approaches in sequence
+                self.add_searchable_annotation(annotator, doc, page_id, text, x, y)
+                    .or_else(|_| {
+                        // If that fails, try to directly modify the content stream
+                        annotator.add_text_to_page(doc, page_id, text, x, y)
+                    })
+            },
+            _ => {
+                // For missing content: create new content stream with our annotation
+                self.create_new_content_stream(doc, page_id, text, x, y)
+            }
+        }
+    }
+
+    /// Handle pages with array content streams
+    fn handle_array_content_page(
+        &self,
+        doc: &mut Document,
+        page_id: (u32, u16),
+        text: &str,
+        x: f32,
+        y: f32,
+    ) -> Result<(), crate::error::AnnotationError> {
+        // Get the existing content array from the page
+        let (contents_array, is_ref, ref_id) = {
+            let page_dict = doc.get_dictionary(page_id).map_err(|e| {
+                crate::error::AnnotationError::ContentStreamError(format!("Failed to get page dictionary: {}", e))
+            })?;
+            
+            match page_dict.get(b"Contents") {
+                Ok(Object::Array(arr)) => (arr.clone(), false, None),
+                Ok(Object::Reference(ref_id)) => {
+                    // Resolve the reference to get the array
+                    match doc.get_object(*ref_id) {
+                        Ok(Object::Array(arr)) => (arr.clone(), true, Some(*ref_id)),
+                        _ => (vec![], true, Some(*ref_id))
+                    }
+                },
+                _ => (vec![], false, None)
+            }
+        };
+        
+        // Create a new content stream with our annotation and append to existing content
+        let content_stream = self.create_annotation_content_stream(doc, text, x, y)?;
+        let content_id = doc.add_object(Stream::new(lopdf::Dictionary::new(), content_stream));
+        
+        // Append our annotation stream to existing content and update page
+        // ... Implementation continues with updating the page content streams
+        
+        Ok(())
+    }
